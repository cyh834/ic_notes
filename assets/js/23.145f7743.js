(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{295:function(t,a,s){t.exports=s.p+"assets/img/architecturezh.4ccb80e0.png"},316:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"集创赛龙芯杯简析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集创赛龙芯杯简析"}},[t._v("#")]),t._v(" 集创赛龙芯杯简析")]),t._v(" "),a("h2",{attrs:{id:"龙芯杯设计指标一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#龙芯杯设计指标一"}},[t._v("#")]),t._v(" 龙芯杯设计指标一")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.片上系统需要在国产FPGA平台上完成搭建\n")])])]),a("p",[t._v("数字电路有FPGA(现场可编程门阵列)与ASIC(专用集成电路)")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CPU就是ASIC，制造完后很难改了，流一次片很贵（便宜的几万几十万？）")])]),t._v(" "),a("li",[a("p",[t._v("FPGA好处是可以重复烧录数字电路,适合前期开发，要求快速迭代或者小批量的产品，但是运行速度可能不如ASIC")])])]),t._v(" "),a("p",[a("strong",[t._v("开发平台")]),t._v("：高云FPGA")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://wiki.sipeed.com/hardware/zh/tang/tang-mega-138k/mega-138k.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("资料"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"龙芯杯设计指标二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#龙芯杯设计指标二"}},[t._v("#")]),t._v(" 龙芯杯设计指标二")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("2.利用龙芯提供的LoongArch处理器核IP与FPGA上的加速器构建的片上系统应该至少包含以下内容：\n\n(1) 基于LoongArch架构的IP核\n\n(2) 实现ROM与RAM数据交互\n\n(3) 与芯片外部引脚连接的信号接口外设\n")])])]),a("p",[t._v("龙芯杯会给我们一个cpu核，所以我们需要先知道cpu的工作原理")]),t._v(" "),a("h3",{attrs:{id:"cpu工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu工作原理"}},[t._v("#")]),t._v(" CPU工作原理")]),t._v(" "),a("p",[t._v("我们想要设计一个数字电路，来帮我们进行计算，比如运行这个程序:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\ti"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ti"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ti"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ti"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ti"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("我们可以加入"),a("code",[t._v("pc")]),t._v(","),a("code",[t._v("a0")]),t._v(","),a("code",[t._v("zero")]),t._v("三个寄存器来完成这个任务，,"),a("code",[t._v("pc")]),t._v("记录目前运行到哪条指令，"),a("code",[t._v("a0")]),t._v("来存储数值，"),a("code",[t._v("zero")]),t._v("永远为0.（也可以采取其他方式，这只是其中一种实现方式）")]),t._v(" "),a("div",{staticClass:"language-asm extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# pc | 二进制 | 汇编\n0000000000000000 <main>:\n   0:   00100513                li      a0,1 \t ## a0 = 1\n   4:   00150513                addi    a0,a0,1  ## a0 = a0 + 1\n   8:   00150513                addi    a0,a0,1  \n   c:   00150513                addi    a0,a0,1\n  10:   00150513                addi    a0,a0,1\n")])])]),a("p",[t._v("这显然就是个简单的状态机")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("现态:由"),a("code",[t._v("pc")]),t._v(","),a("code",[t._v("a0")]),t._v("与存储指令的存储器决定")])]),t._v(" "),a("li",[a("p",[t._v("次态:由现态和组合逻辑电路决定")])]),t._v(" "),a("li",[a("p",[t._v("初始状态:复位时时序逻辑元件的值")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("什么是复位？")]),t._v(" "),a("p",[t._v("在所有寄存器的值开始都是未知，所以我们必须为先为它们赋一个初值，确定现态，不然谁知道它的次态会是什么.")]),t._v(" "),a("p",[t._v("复位的实现也很简单，增加reset作为输入信号，每当reset为低电平或者高电平时，为寄存器赋初值")]),t._v(" "),a("div",{staticClass:"language-verilog extra-class"},[a("pre",{pre:!0,attrs:{class:"language-verilog"}},[a("code",[a("span",{pre:!0,attrs:{class:"token important"}},[t._v("always @")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("posedge")]),t._v(" clock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("begin")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当时钟上升沿来临时，运行下面的指令")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("！reset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("begin")]),t._v("\t\t "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果reset为低电平，pc,a0置0")]),t._v("\n\t\tpc"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\ta0"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" \n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n    zero"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// zero永远为0")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n")])])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("指令集")]),t._v(" "),a("p",[t._v("c语言会翻译成怎么样的汇编，会翻译成怎么样的二进制？")]),t._v(" "),a("p",[t._v("这主要看我们用的是什么指令集（当然还会有编译器优化等次要因素）")]),t._v(" "),a("p",[t._v("指令集就是一个手册、一个规范，规定汇编、二进制代码该是什么格式，只有程序按照指令集的规定翻译成正确的二进制，这个数字电路按照指令集的规定设计，才能正常运行.")]),t._v(" "),a("p",[t._v("这里主要用risc-v指令集，因为龙芯杯需要的LoongArch架构我还没学")])]),t._v(" "),a("p",[t._v("现在这个数字电路需要做如下工作")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  从PC指示的存储器位置取出指令"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  执行指令"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  更新PC"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"取出指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#取出指令"}},[t._v("#")]),t._v(" 取出指令")]),t._v(" "),a("h4",{attrs:{id:"程序的存放"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序的存放"}},[t._v("#")]),t._v(" 程序的存放")]),t._v(" "),a("p",[t._v("首先需要考虑程序放在哪里，我们才能把它们取出来. 一般的存储器是易失存储器(volatile memory), 例如SRAM和DRAM, 它们在上电时并没有存放有效数据. 如果上电后这个数字电路直接从内存中读取指令执行, 存储器读出什么数据是未定义的, 因此整个系统的行为也是未定义的, 从而无法让这个数字电路执行预期的程序.")]),t._v(" "),a("p",[t._v("因此, 需要使用一种非易失存储器(non-volatile memory)来存放最初的程序, 使其内容能在断电时保持, 并在上电时能让这个数字电路马上从中取出指令. 一个最简单的解决方案就是ROM(Read-Only Memory), 每次从ROM中相同位置读出的内容都是相同的.")]),t._v(" "),a("p",[t._v("刚开始的ROM做好了就改不了了，只能找晶圆厂重新流片，就像一个雕好的雕像很难更改，只能重新找块石头雕.随着存储技术的发展, 人们发明了可重复编程和擦除的ROM, 目前广泛使用的flash存储器就是其中一种. 用户能够在某些条件下擦除flash存储器中存放的内容, 并重新进行写入. 通常来说, 用户只需要购买一个数十元的烧录器, 即可通过烧录软件更新flash中的内容. 通过这种方式, 更换flash中存放的程序的代价变得可以接受.")]),t._v(" "),a("p",[t._v("flash特点是写入很麻烦，但读取很简单.不过我们一般用它读取指令就行了，只有重新烧录程序时才需要写入.")]),t._v(" "),a("h4",{attrs:{id:"与flash进行交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与flash进行交互"}},[t._v("#")]),t._v(" 与flash进行交互")]),t._v(" "),a("p",[t._v("我们需要告诉flash我们现在要取哪条指令，也就是指令的地址.因为"),a("code",[t._v("pc")]),t._v("寄存器与指令一一对应，所以这可以是"),a("code",[t._v("pc")]),t._v("寄存器的值减一个偏移量.")]),t._v(" "),a("p",[t._v("为什么有偏移量？因为我们可以：")]),t._v(" "),a("div",{staticClass:"language-asm extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   0:   00100513                li      a0,0\n   4:   00150513                addi    a0,a0,1\n")])])]),a("p",[t._v("也可以：")]),t._v(" "),a("div",{staticClass:"language-asm extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   30000000:   00100513                li      a0,0\n   30000004:   00150513                addi    a0,a0,1\n")])])]),a("p",[t._v("把"),a("code",[t._v("pc")]),t._v("的复位值从"),a("code",[t._v("0")]),t._v("改成"),a("code",[t._v("0x30000000")]),t._v("就行了")]),t._v(" "),a("p",[t._v("对于后者，与flash交互的数字电路模块要记得减去"),a("code",[t._v("0x30000000")]),t._v(",或者干脆只取"),a("code",[t._v("pc")]),t._v("寄存器的后24位，前8位不要了，反正flash的容量未必能装下那么多的指令.")]),t._v(" "),a("p",[t._v("为什么"),a("code",[t._v("pc")]),t._v("要从"),a("code",[t._v("0x30000000")]),t._v("或者其他地方开始，而不是固定从0开始？因为部分地址可能另有它用.")]),t._v(" "),a("p",[t._v("那怎么告诉flash指令的地址？")]),t._v(" "),a("p",[t._v("最简单是方法是在双方连接32根地址线，一根线传输一个高电平或者低电平.我们提前约定好哪根线传输地址的低位，哪根线传输高位，32根线就能一个时钟周期传输完32位地址了.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("时钟周期")]),t._v(" "),a("p",[t._v("寄存器只有在时钟信号上升沿或者下降沿才能更新，时钟信号从高电平到低电平再到高电平所需时间就是一个时钟周期")])]),t._v(" "),a("h4",{attrs:{id:"总线协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总线协议"}},[t._v("#")]),t._v(" 总线协议")]),t._v(" "),a("p",[t._v("想法是美好的，但因为flash颗粒的制造工艺与处理器的制造工艺不同, 因此处理器芯片和flash颗粒芯片要单独制造生产, 然后再焊接到板卡上, 通过板卡上的走线来通信. 也因为这样, 引脚数量就成了一个需要考虑的问题. 一方面, 如果引脚数量太多, 就不利于将芯片做小, 这对板卡的布局和面积都会产生负面影响; 另一方面, 板卡上的走线距离通常比芯片内部的走线要长, 信号也更容易受到干扰, 故引脚数量太多也会导致板卡上走线密集, 这些走线之间也很容易相互干扰, 影响信号的稳定性.")]),t._v(" "),a("p",[t._v("我们可能只用几根线分批次传输地址，先传这几位，再传那几位.")]),t._v(" "),a("p",[t._v("具体用几根线，怎么传输，需要双方遵循统一的协议，不能一个说中文，一个说英语，这就是总线协议.")]),t._v(" "),a("p",[t._v("因为几根线，每根传输什么数据，什么时候传输等因素要具体问题具体分析，也就有了不同的总线协议.与flash交互一般用SPI协议.")]),t._v(" "),a("p",[t._v("SPI协议内容具体我懒得写了，自己上网查，只能说挺重要的.")]),t._v(" "),a("p",[t._v("除了地址，我们还需要告诉flash其他信息，比如是什么命令，读命令？写命令？至于命令的格式和功能, 当然是由"),a("a",{attrs:{href:"https://evelta.com/content/datasheets/153-W25Q128JVSIQ.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("相应的手册"),a("OutboundLink")],1),t._v("来定义了.命令的传输也要遵循SPI总线协议.")]),t._v(" "),a("p",[t._v("最后SPI会返回我们指令，同样需要依据SPI总线协议.")]),t._v(" "),a("h3",{attrs:{id:"执行指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行指令"}},[t._v("#")]),t._v(" 执行指令")]),t._v(" "),a("p",[t._v("我们需要从取出的指令中识别出我们要进行什么操作，对什么寄存器进行操作等信息，然后执行它.")]),t._v(" "),a("p",[t._v("比如这个程序就是对一些做加法")]),t._v(" "),a("h3",{attrs:{id:"更新pc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新pc"}},[t._v("#")]),t._v(" 更新PC")]),t._v(" "),a("p",[a("code",[t._v("pc = pc+4")]),t._v(" ，这样接着就能取下一条指令.")]),t._v(" "),a("h3",{attrs:{id:"加入分支指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加入分支指令"}},[t._v("#")]),t._v(" 加入分支指令")]),t._v(" "),a("p",[t._v("为了这个数字电路能运行条件和循环语句，我们可以加入分支指令，如果不符合条件（比如寄存器"),a("code",[t._v("a0")]),t._v(","),a("code",[t._v("a1")]),t._v("的值不相等），我们修改一下"),a("code",[t._v("pc")]),t._v("就行了.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("0000000000000000 <_start>:\n  0: li a0,1        ## a0 = 1\n  4: li a1,8\t\t## a1 = 8\n  8: addi a0,a0,1\t## a0 = a0 + 1\n  c: bne a0,a1,8\t## pc = (a0 != a1) ? 8 : pc+4\n 10: j 10           ## pc = 0x10,死循环\n")])])]),a("p",[t._v("在数字电路视角下，我们可以通过减法器来计算分支是否跳转，再给"),a("code",[t._v("pc")]),t._v("加个选择器")]),t._v(" "),a("h3",{attrs:{id:"加入访存指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加入访存指令"}},[t._v("#")]),t._v(" 加入访存指令")]),t._v(" "),a("p",[t._v("寄存器一般就几个或者几十个，遇到复杂计算，不可能总是把数据储存在寄存器里.我们需要一个专门的存储器，来临时保存，容量比寄存器大，但速度可能不如寄存器（给它地址，可能需要几十个时钟周期才返回数据,具体要看什么存储器，有快有慢）.与flash不同的是，这个存储器要支持随机读写，flash想随便写一个字节太麻烦了.")]),t._v(" "),a("p",[t._v("在DRAM中，每个记忆单元由一个电容和一个开关电路组成，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特是1还是0.由于存在DRAM中的资料会在断电后很快就没了，因此它属于一种易失性存储器设备.所以程序的存放还是得靠flash这种非易失存储器.DRAM只能在程序运行时存储一下数据.")]),t._v(" "),a("p",[t._v("PSRAM,SDRAM都属于DRAM的一种，我们可能熟悉的DDR，就是DDR SDRAM.")]),t._v(" "),a("p",[t._v("为了与DRAM交互，我们需要专门的访存指令")]),t._v(" "),a("p",[t._v("为什么从flash交互不需要专门的指令？因为不管执行什么指令，你都需要取指.是否与DRAM交互则要看你的执行的什么程序了.")]),t._v(" "),a("div",{staticClass:"language-asm extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("li  a0,0x1000 ## a0 = 0x1000\nsb\ta1,0(a0)  ## *(uint8_t *)(a0 + 0) = a1\n\t\t\t  ## 将寄存器 a1 中的值存储到寄存器 a0 指向的内存地址（偏移量为 0）中.\nlb  a2,0(a0)  ## a2 = *(uint8_t *)(a1 + 0)\n\t\t\t  ## 从寄存器 a0 指向的内存地址（偏移量为 0）中加载一个字节的数据到寄存器 a2 中.\n")])])]),a("p",[t._v("在数字电路视角下，我们识别出现在是个访存指令，需要通过特定的总线协议与存储器交互，比如AXI,AHB,APB协议等.")]),t._v(" "),a("h3",{attrs:{id:"输入与输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入与输出"}},[t._v("#")]),t._v(" 输入与输出")]),t._v(" "),a("p",[t._v("上面的程序运行成功了，但是没太大用，因为结果没有输出出来，我们也很难得知计算结果是什么.")]),t._v(" "),a("p",[t._v("我们希望与一个输出设备通信，比如说串口(UART)")]),t._v(" "),a("p",[t._v("为了省事，我们可以规定"),a("code",[t._v("0x1000_0000~0x1000_0fff")]),t._v("或者其他地方为串口的地址空间，我们对这些地址进行访存操作，就相当于读写串口外设控制器的寄存器.这个方式叫mmio.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("为什么是读写外设控制器的寄存器")]),t._v(" "),a("p",[t._v("还记得最开始讲的状态机模型吗？我们读写外设控制器的寄存器，就能读入/改变外设的状态，从而控制外设.")])]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro-name"}},[t._v("UART_TX")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x10000000L")])])])])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UART_TX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'\\n'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("如果我们把putch用其他函数封装一下，就是熟悉的printf了")]),t._v(" "),a("p",[t._v("输入同理，就是写指令变成读指令")]),t._v(" "),a("h3",{attrs:{id:"多个设备的系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个设备的系统"}},[t._v("#")]),t._v(" 多个设备的系统")]),t._v(" "),a("p",[t._v("不过你们有没有发现一个问题，假设这个数字电路用"),a("code",[t._v("addr[31:0]")]),t._v("这32根线来表示访存的地址，那这32根线怎么同时与多个外设相连？")]),t._v(" "),a("p",[t._v("实际上, 硬件是通过crossbar（有时也写作Xbar）模块来实现mmio. Xbar是一个总线的多路开关模块, 可以根据输入端的总线请求的地址, 将请求转发到不同的输出端, 从而传递给不同的下游模块. 这些下游模块可能是设备, 也可能是另一个Xbar. 例如, 下图中的Arbiter用于从IFU和LSU中选择一个请求转发给下游, 下游的Xbar收到请求后, 根据请求中的地址将其转发给下游设备.")]),t._v(" "),a("p",[t._v("说白了就是复杂点的选择器.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("+-----+      +---------+      +------+      +-----+\n| IFU | ---\x3e |         |      |      | ---\x3e | UART|  [0x1000_0000, 0x1000_0fff)\n+-----+      |         |      |      |      +-----+\n             | Arbiter | ---\x3e | Xbar |\n+-----+      |         |      |      |      +-----+\n| LSU | ---\x3e |         |      |      | ---\x3e | SRAM|  [0x8000_0000, 0x80ff_ffff)\n+-----+      +---------+      +------+      +-----+\n")])])]),a("p",[t._v("对了，忘记给这个数字电路取名了，不如就叫CPU吧.")]),t._v(" "),a("h2",{attrs:{id:"龙芯杯设计指标三"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#龙芯杯设计指标三"}},[t._v("#")]),t._v(" 龙芯杯设计指标三")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("3. 结合场景需求，为处理器原型添加符合场景需求的智能处理功能、人机交互功能、信号采集功能\n")])])]),a("p",[a("strong",[t._v("任务")]),t._v(" :信号处理、AI识别等等")]),t._v(" "),a("ul",[a("li",[t._v("需要场景与合适的算法/模型，估计是找别人算法或者模型，自己写的模型效率可能很难超过网上的模型")]),t._v(" "),a("li",[t._v("我还没怎么找就不多哔哔了")])]),t._v(" "),a("h2",{attrs:{id:"进阶指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进阶指标"}},[t._v("#")]),t._v(" 进阶指标")]),t._v(" "),a("p",[a("strong",[t._v("自行设计外围IP")]),t._v(":")]),t._v(" "),a("ul",[a("li",[t._v("比赛方会提供GPIO、I2C等通用接口IP.IP就是别人写好的模块，你可以拿来直接用，不过出于保密，你可能看不到它的源代码.有了IP就像我们写c语言可以直接调用别人函数库的函数，方便了不少.")]),t._v(" "),a("li",[t._v("如果不提供UART，SPI等接口/总线协议，而我们可能就要自己写了.")])]),t._v(" "),a("p",[a("strong",[t._v("FPGA加速")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("CPU一般是一个指令一个指令的执行，虽然流水线和超标量等技术可以一次执行多条指令，但并行度仍然有限")]),t._v(" "),a("li",[t._v("我们可以在FPGA上烧录10000个运算单元，很快就能得到10000个结果，直接碾压CPU")]),t._v(" "),a("li",[t._v("我们可以通过CPU的写指令给FPGA上的模块提供数据，通过读指令获取结果，这就是FPGA加速")])]),t._v(" "),a("p",[a("strong",[t._v("添加国产操作系统")]),t._v("：")]),t._v(" "),a("p",[t._v("我们之前为了输出字符，需要:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token macro-name"}},[t._v("UART_TX")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x10000000L")])])])])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UART_TX"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("putch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token char"}},[t._v("'\\n'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("那换台机器，UART的位置不在"),a("code",[t._v("0x10000000")]),t._v("了，这个程序是不是就不能运行了？那岂不是对不同型号的机器都要重新开发程序.程序员是人，不是帕鲁，累死后不能复活.")]),t._v(" "),a("p",[t._v("其实我们可以只重新实现"),a("code",[t._v("putch")]),t._v("等少数与硬件直接相关的函数，其他的"),a("code",[t._v("printf")]),t._v("基于这些与硬件直接相关的函数，这样我们换新硬件，只需要重新实现少数与硬件直接相关的函数，就能继续运行其他程序了")]),t._v(" "),a("p",[t._v("操作系统就能提供这些"),a("strong",[t._v("对计算机资源的抽象")])]),t._v(" "),a("p",[t._v("看看RT-Thread的官方文档：")]),t._v(" "),a("p",[t._v("RT-Thread是一个集实时操作系统（RTOS）内核、中间件组件的物联网操作系统，架构如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(295),alt:"architecturezh"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("内核层：RT-Thread内核，是 RT-Thread的核心部分，包括了内核系统中对象的实现，例如多线程及其调度、信号量、邮箱、消息队列、内存管理、定时器等；libcpu/BSP（芯片移植相关文件 / 板级支持包）与硬件密切相关，由外设驱动和 CPU 移植构成.")])]),t._v(" "),a("li",[a("p",[t._v("组件与服务层：组件是基于 RT-Thread内核之上的上层软件，例如虚拟文件系统、FinSH命令行界面、网络框架、设备框架等.采用模块化设计，做到组件内部高内聚，组件之间低耦合.")])]),t._v(" "),a("li",[a("p",[t._v("RT-Thread软件包：运行于 RT-Thread物联网操作系统平台上，面向不同应用领域的通用软件组件，由描述信息、源代码或库文件组成.RT-Thread提供了开放的软件包平台，这里存放了官方提供或开发者提供的软件包，该平台为开发者提供了众多可重用软件包的选择，这也是 RT-Thread生态的重要组成部分.软件包生态对于一个操作系统的选择至关重要，因为这些软件包具有很强的可重用性，模块化程度很高，极大的方便应用开发者在最短时间内，打造出自己想要的系统.RT-Thread已经支持的软件包数量已经达到450+.")])])]),t._v(" "),a("p",[t._v("RT-Thread源代码目录结构如下图所示：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("名称")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("BSP")]),t._v(" "),a("td",[t._v("Board Support Package（板级支持包）基于各种开发板的移植")])]),t._v(" "),a("tr",[a("td",[t._v("components")]),t._v(" "),a("td",[t._v("RT-Thread 的各个组件代码，例如 finsh，gui 等.")])]),t._v(" "),a("tr",[a("td",[t._v("documentation")]),t._v(" "),a("td",[t._v("相关文档，如编码规范等")])]),t._v(" "),a("tr",[a("td",[t._v("examples")]),t._v(" "),a("td",[t._v("相关示例代码")])]),t._v(" "),a("tr",[a("td",[t._v("include")]),t._v(" "),a("td",[t._v("RT-Thread 内核的头文件.")])]),t._v(" "),a("tr",[a("td",[t._v("libcpu")]),t._v(" "),a("td",[t._v("各类芯片的移植代码.")])]),t._v(" "),a("tr",[a("td",[t._v("src")]),t._v(" "),a("td",[t._v("RT-Thread 内核的源文件.")])]),t._v(" "),a("tr",[a("td",[t._v("tools")]),t._v(" "),a("td",[t._v("RT-Thread 命令构建工具的脚本文件.")])])])]),t._v(" "),a("p",[t._v("libcpu选择LoongArch架构,再根据开发板改改BSP,理论上就没问题了.如果我们的开发板已经被提供了相应的BSP，那BSP都不用改了.")]),t._v(" "),a("p",[t._v("如果因为我说得不对或者其他原因导致移植不成功，建议去参考官方文档，他们有中文版教程")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/RT-Thread/rt-thread/blob/master/README_zh.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("RT-thread"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/openharmony/docs/blob/master/zh-cn/readme.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenHarmony"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"提交资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提交资料"}},[t._v("#")]),t._v(" 提交资料")]),t._v(" "),a("ol",[a("li",[t._v("技术文档")]),t._v(" "),a("li",[t._v("设计数据")]),t._v(" "),a("li",[t._v("功能演示视频")]),t._v(" "),a("li",[t._v("…")])]),t._v(" "),a("p",[t._v("这些以后再说")])])}),[],!1,null,null,null);a.default=e.exports}}]);